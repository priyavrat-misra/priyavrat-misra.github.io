<!doctype html><html lang=en><head><title>A Voyage to Structs</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=author content="Priyavrat Misra"><meta name=description content="Part 1: Defining, Initializing and Assigning Structs."><link rel=canonical href=https://priyavr.at/blog/structs-i/><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link href=https://cdn.jsdelivr.net/npm/bootstrap@5.3.8/dist/css/bootstrap.min.css rel=stylesheet integrity=sha384-sRIl4kxILFvY47J16cr9ZwB07vP4J8+LH7qKQnuqkuIAvNWLzeN8tE5YBujZqJLB crossorigin=anonymous><link rel=stylesheet href=/css/theme.min.css></head><body><div id=content class=mx-auto><header class="container mt-4"><div class=row><div class="col-sm-4 col-12 text-sm-end text-center pt-sm-4"><a href=/ class=text-decoration-none><img id=avatar height=120px width=120px alt="Profile Picture" src=/images/avatar/120x120.webp srcset="/images/avatar/180x180.webp 180w, /images/avatar/120x120.webp 120w" sizes="(width <= 600px) 180px, 120px"></a></div><div class="col-sm-8 col-12 text-sm-start text-center"><h1 class="mb-2 mt-4"><a href=/ class=text-decoration-none>Priyavrat Misra</a></h1><p class="text-muted subtitle"></p><nav><ul class=list-inline><li class=list-inline-item><a href=https://www.linkedin.com/in/priyavrat-misra/ title=LinkedIn target=_blank class=text-muted><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M16 8a6 6 0 016 6v7h-4v-7a2 2 0 00-2-2 2 2 0 00-2 2v7h-4v-7a6 6 0 016-6z"/><rect x="2" y="9" width="4" height="12"/><circle cx="4" cy="4" r="2"/></svg></a></li><li class=list-inline-item><a href=https://github.com/priyavrat-misra title=GitHub target=_blank class=text-muted><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a></li><li class=list-inline-item><a href=https://www.strava.com/athletes/priyavrat title=Strava target=_blank class=text-muted><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><polyline points="22 12 18 12 15 21 9 3 6 12 2 12"/></svg></a></li><li class=list-inline-item><a href=mailto:priyavratmisra123@gmail.com title=Email target=_blank class=text-muted><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M4 4h16c1.1.0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1.0-2-.9-2-2V6c0-1.1.9-2 2-2z"/><polyline points="22,6 12,13 2,6"/></svg></a></li><li class=list-inline-item><a href=/blog/rss.xml title="RSS Feed" target=_blank class=text-muted><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></li></ul></nav><nav><ul class=list-inline><li class=list-inline-item><strong><a href=/blog/ title="Ramblings for the curious mind.">Blog</a></strong></li><li class=list-inline-item><strong><a href=/tags/ title=Tags>Tags</a></strong></li><li class=list-inline-item><strong><a href=https://nbviewer.org/github/priyavrat-misra/resume/blob/main/R%C3%A9sum%C3%A9.pdf title=Résumé>Résumé</a></strong></li></ul></nav></div></div><hr></header><main class=container><header class=mb-3><h1 class=mb-0>A Voyage to Structs</h1><aside>Definition, Initialization and Assignment.</aside><small class=text-muted>Published: <time>12 Feb 25 03:25 UTC</time></small>
<small class=text-muted>Last updated: <time>14 Sep 25 03:12 UTC</time></small><br><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z"/><line x1="7" y1="7" x2="7.01" y2="7"/></svg>
<a href=/tags/c++ class="badge bg-secondary text-decoration-none">c++</a>
<a href=/tags/programming class="badge bg-secondary text-decoration-none">programming</a><nav id=TableOfContents><ul><li><a href=#motivation>Motivation</a></li><li><a href=#introduction>Introduction</a></li><li><a href=#defining-structs>Defining Structs</a></li><li><a href=#initializing-structs>Initializing Structs</a><ul><li><a href=#what-is-an-aggregate>What is an <em>aggregate</em>?</a></li><li><a href=#value-initialization>Value-initialization</a></li><li><a href=#aggregate-initialization>Aggregate-initialization</a><ul><li><a href=#initializing-with-ordinary-initializer-lists>initializing with ordinary initializer lists</a></li><li><a href=#initializing-with-designated-initializers>initializing with designated initializers</a></li></ul></li><li><a href=#initializing-from-a-struct>Initializing from a Struct</a></li></ul></li><li><a href=#assigning-structs>Assigning Structs</a><ul><li><a href=#assigning-with-initializer-lists>assigning with initializer lists</a></li><li><a href=#assigning-another-struct-using-operator>assigning another struct using <code>operator=</code></a></li></ul></li><li><a href=#to-be-continued>To Be Continued&mldr;</a></li></ul></nav></header><article><h2 id=motivation>Motivation</h2><p>I’m back, folks! Though I must admit, I’m a little rusty. It’s been a while since I’ve written anything. Life, as it tends to do, got in the way—new job, new priorities, you know the drill. I’m not entirely sure what inspired me to dust off my portfolio today. Perhaps it was the domain renewal email or perhaps it was the realization that two years have passed since I started writing an article that&rsquo;s still lingering in draft form, waiting for its chance to shine (or, more likely, to be completely rewritten). But today I&rsquo;m dusting myself off and diving back in, ready to share some fresh thoughts. Join me, if you will, on <em>A Voyage to Structs</em>.</p><blockquote><p>A quick note: this article focuses exclusively on structs in C++, though most of the concepts here are applicable to C, and some might even apply to other <a href=https://en.wikipedia.org/wiki/List_of_C-family_programming_languages target=_blank>C-family languages</a>. But hey, no promises.</p></blockquote><h2 id=introduction>Introduction</h2><p>Let’s kick things off with a definition from <em>cppreference</em>:</p><blockquote><p>A struct is a type consisting of a sequence of members whose storage is allocated in an ordered sequence.</p></blockquote><p>Now, if you’re paying attention, that might sound a lot like arrays. But here’s the catch: it doesn’t say anything about the data type of the members. This means we can have members of different types—whether fundamental or compound. This flexibility makes structs more complex in memory layout compared to arrays (<em>spoiler: this will be the subject of a future article</em>).</p><p>So, what does &ldquo;type&rdquo; mean in this context? Well, here’s a quick breakdown:</p><ul><li><strong>A user-defined type</strong>: You create it. You define it. It’s yours.</li><li><strong>A compound type</strong>: These are types made up of other types (basically the &ldquo;Frankenstein&rdquo; of types).</li><li><strong>A class type</strong>: This could be a <code>struct</code>, <code>class</code>, or <code>union</code>.</li><li><strong>A program-defined type</strong>: In C++20, this refers to class and enum types <em>we</em> define, not those that come with the standard library or the core language.</li></ul><h2 id=defining-structs>Defining Structs</h2><p>Since structs are program-defined types, we need to describe them to the compiler before we use them. Structs can either have a name (a <em>type tag</em>) or not. If there’s no name, we call them anonymous structs—pretty self-explanatory. Anonymous structs are useful in special contexts, like inside a <code>typedef</code> or <code>union</code>.</p><p>Let’s start with how structs are defined in C, and then we’ll dive into some C++ additions.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>struct</span> Direction {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> dx;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> dy;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// initialization
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> Direction north;
</span></span><span style=display:flex><span>north.dx <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>north.dy <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span></code></pre></div><p>Notice during initialization how we had to mention <code>struct</code> again. This is because <code>Direction</code> is defined in the <em>tag name space</em>, not mentioning <code>struct</code> would lead the compiler to search for it in the <em>ordinary identifier name space</em> and lead to a compiler error.</p><blockquote><p>The C language standard (<a href=http://port70.net/~nsz/c/c89/c89-draft.txt target=_blank>C89</a>, <a href=http://port70.net/~nsz/c/c99/n1256.html#6.2.3 target=_blank>C99</a>, and <a href=http://port70.net/~nsz/c/c11/n1570.html#6.2.3 target=_blank>C11</a>) mandates separate name spaces for different categories of identifiers, including tag identifiers (for <code>struct</code>/<code>union</code>/<code>enum</code>) and ordinary identifiers (for <code>typedef</code> and other identifiers).</p></blockquote><p>The following example declares an anonymous struct and creates a <code>typedef</code> for it. Thus, with this construct, it doesn&rsquo;t have a name in the <em>tag name space</em>. Hence no need to prefix <code>struct</code> everytime it is referenced.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> dx;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> dy;
</span></span><span style=display:flex><span>} Direction;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Direction north;
</span></span><span style=display:flex><span>north.dx <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>north.dy <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span></code></pre></div><p>This approach saves us from typing <code>struct</code> every time we reference <code>Direction</code>. However, it’s considered bad practice by some, including the <a href=https://www.kernel.org/doc/html/latest/process/coding-style.html#typedefs target=_blank>Linux kernel coding style guidelines</a>.</p><p>And here&rsquo;s the kicker: with anonymous structs, you can&rsquo;t do this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>struct</span> Node {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> val;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> Node<span style=color:#f92672>*</span> next; <span style=color:#75715e>// recursively refers to `struct Node`
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>};
</span></span></code></pre></div><p>In C++, the <em>tag name space</em> still exists, but all names are automatically added to both the <em>tag name space</em> and the <em>ordinary identifier name space</em>, which means we no longer need to type <code>struct</code> everywhere. Sweet, right?</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Direction</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> dx;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> dy;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Direction north; <span style=color:#75715e>// no need for `struct`
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>north.dx <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>north.dy <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>struct</span> Node {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> val;
</span></span><span style=display:flex><span>    Node<span style=color:#f92672>*</span> next; <span style=color:#75715e>// no need for `struct`
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>};
</span></span></code></pre></div><h2 id=initializing-structs>Initializing Structs</h2><p>In the previous section, to keep the examples simple, I have instantiated the structs and assigned the values one by one. It may be considered as one form of initialization but it is not a good practice to do so. In a way it violates the <em>always initialize</em> rule from the <a href=https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#es20-always-initialize-an-object target=_blank>C++ Core Guidelines</a>. It can be a bit error-prone, especially since some members might slip through the cracks and be left uninitialized—leading to undefined behavior or garbage values. To avoid this, we need to properly initialize our structs.</p><p>To correctly initialize a struct, we first have to get familiar with <em>aggregates</em>.</p><h3 id=what-is-an-aggregate>What is an <em>aggregate</em>?</h3><p>The formal definition of an aggregate has changed throughout the C++ standards. There have been few rules added and few removed, however the following stayed consistent throughout all the standards.</p><blockquote><p>An <em>aggregate</em> is any data type with multiple members, it can either be an array type or a class type with:</p><ul><li>no private or protected non-static data members</li><li>no virtual member functions</li></ul><p><em>An up-to-date and precise definition can be found <a href=https://en.cppreference.com/w/cpp/language/aggregate_initialization target=_blank>here</a>.</em></p></blockquote><p>You might be tempted to think that structs are always aggregates, but that’s not true. In C++, classes and struct are the same except for their default behaviour with regards to inheritance and access levels of members. For classes both are private whereas for struct both are public. Because of this classes and structs can be used interchangeably, and so there is a possibility of a <em>non-aggregate</em> struct. But for our purposes, we’ll stick with the assumption that structs with only data members are aggregates.</p><p>Before delving into <em>aggregate-initialization</em>, let&rsquo;s take a short detour.</p><h3 id=value-initialization>Value-initialization</h3><p>In C++11 and beyond, <em>value-initialization</em> occurs when a variable is initialized using an empty brace-enclosed initializer list.</p><p>If a scalar type (<code>bool</code>, <code>int</code>, <code>char</code>, <code>double</code>, pointers, etc.) is initialized this way then they are zero-initialized.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>double</span> d {}; <span style=color:#75715e>// value-initialized to 0.0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span><span style=color:#f92672>*</span> p {}; <span style=color:#75715e>// value-initialized to NULL 
</span></span></span></code></pre></div><p>Whereas, for aggregate types if this form of initialization is used then <em>aggregate-initialization</em> is performed instead.</p><h3 id=aggregate-initialization>Aggregate-initialization</h3><p>There are four ways to initialize an aggregate, all of which are various forms of <a href=https://en.cppreference.com/w/cpp/language/list_initialization target=_blank>list-initialization</a>.</p><ul><li>Initializing an aggregate with an ordinary initializer list.</li></ul><ol><li><code>T object = { arg1, arg2, ... };</code></li><li><code>T object { arg1, arg2, ... };</code> (since <em>C++11</em>)</li></ol><ul><li>Initializing an aggregate with designated initializers (applicable only to class types).</li></ul><ol start=3><li><code>T object = { .des1 = arg1 , .des2 { arg2 } ... };</code> (since <em>C++20</em>)</li><li><code>T object { .des1 = arg1 , .des2 { arg2 } ... };</code> (since <em>C++20</em>)</li></ol><p>Here, 2 and 4 are termed <em>direct list initialization</em> and, 1 and 3 are termed <em>copy list initialization</em>.</p><h4 id=initializing-with-ordinary-initializer-lists>initializing with ordinary initializer lists</h4><p>This syntax (<em>1, 2</em>) is commonly used when initializing arrays, which can be generalized to aggregates.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> oneDigitPrimes[]{<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>7</span>}; <span style=color:#75715e>// or oneDigitPrimes[] = {2, 3, 5, 7}
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span><span style=color:#f92672>*</span> oneDigitPrimesHeap <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>int</span>[]{<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>7</span>};
</span></span></code></pre></div><p>is equivalent to,</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> oneDigitPrimes[<span style=color:#ae81ff>4</span>]{<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>7</span>}; <span style=color:#75715e>// or oneDigitPrimes[4] = {2, 3, 5, 7}
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span><span style=color:#f92672>*</span> oneDigitPrimesHeap <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>int</span>[<span style=color:#ae81ff>4</span>]{<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>7</span>};
</span></span></code></pre></div><p>In the above example, there wasn&rsquo;t a need of mentioning the size, as it can be deduced by the compiler from the brace-enclosed initializer list. However, it can be explicitly mentioned as well, resulting in following three scenarios:</p><ol><li>the array size is equal to the initializer list size (size can be omitted, like the above example)</li><li>the array size is less than the initializer list size (this will lead to a compiler error)</li><li>the array size is greater than the initializer list size (each array element is initialized in the order of declaration and the others are initialized from an empty initializer list)</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> f[<span style=color:#ae81ff>26</span>]{<span style=color:#ae81ff>0</span>}; <span style=color:#75715e>// 1st element is assigned 0, others are value-initialized (to 0)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> m[<span style=color:#ae81ff>26</span>]{}; <span style=color:#75715e>// all the elements are value-initialized (to 0)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> z[] <span style=color:#f92672>=</span> {}; <span style=color:#75715e>// Error: cannot declare an array without any element
</span></span></span></code></pre></div><p>These points hold true even for structs but with a slightly modified point 3,</p><ul><li>all the members without any initializer in the initializer list having a default value are assigned that value. And the other members are initialized from an empty initializer list i.e., value-initialized.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Person</span> {
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>string name;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> age {<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>};
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>double</span> height;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Person person1; <span style=color:#75715e>// name = &#34;&#34;, age = -1, height = undefined behavior
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>Person person2 {}; <span style=color:#75715e>// name = &#34;&#34;, age = -1, height = 0.0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>Person jane {<span style=color:#e6db74>&#34;Jane Doe&#34;</span>}; <span style=color:#75715e>// age = -1, height = 0.0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>Person john {<span style=color:#e6db74>&#34;John Doe&#34;</span>, <span style=color:#ae81ff>22</span>}; <span style=color:#75715e>// height = 0.0
</span></span></span></code></pre></div><p>Did you notice <code>person1.name</code> was initialized with empty string but not garbage? This is so because <code>name</code> is a class type, and for a class type if there are no braces, they are implicitly initialized with an empty initializer list, which in turn invokes the default constructor. Here in this case, the default constructor for <code>std::string</code> initializes <code>name</code> to an empty string.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Address</span> {
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>string city;
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>string state <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;CA&#34;</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> zip <span style=color:#f92672>=</span> <span style=color:#ae81ff>90001</span>;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Person</span> {
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>string name;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> age {<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>};
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>double</span> height;
</span></span><span style=display:flex><span>    Address address;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Person person1 {}; <span style=color:#75715e>// address will be initialized like so `Address address {};`
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>Person person2 {<span style=color:#e6db74>&#34;Jane&#34;</span>, <span style=color:#ae81ff>21</span>, <span style=color:#ae81ff>180</span>, {<span style=color:#e6db74>&#34;LA&#34;</span>}}; <span style=color:#75715e>// or `{&#34;Jane&#34;, 21, 180, &#34;LA&#34;}`
</span></span></span></code></pre></div><p>Above <code>person2</code> was initialized in a nested form, usually seen if the members are aggregates. The inner braces can be omitted provided the sequence of values match that of an aggregate flattened.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> a[<span style=color:#ae81ff>2</span>][<span style=color:#ae81ff>3</span>] <span style=color:#f92672>=</span> {{<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>}, {<span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>6</span>}}; <span style=color:#75715e>// same as `{1, 2, 3, 4, 5, 6}` 
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Student</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> id {<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>};
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> name[<span style=color:#ae81ff>20</span>];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> marks[<span style=color:#ae81ff>3</span>];
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Course</span> {
</span></span><span style=display:flex><span>    Student student;  <span style=color:#75715e>// Nested structure
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>double</span> grade;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Course c1 <span style=color:#f92672>=</span> {{<span style=color:#ae81ff>1234</span>, <span style=color:#e6db74>&#34;Alice&#34;</span>, {<span style=color:#ae81ff>85</span>, <span style=color:#ae81ff>90</span>, <span style=color:#ae81ff>88</span>}}, <span style=color:#ae81ff>90.5</span>};
</span></span><span style=display:flex><span><span style=color:#75715e>// same as `{1234, &#34;Alice&#34;, 85, 90, 88, 90.5}`
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// if `marks[2]` is unknown
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>Course c2 <span style=color:#f92672>=</span> {<span style=color:#ae81ff>1111</span>, <span style=color:#e6db74>&#34;Bob&#34;</span>, {<span style=color:#ae81ff>90</span>, <span style=color:#ae81ff>95</span>}, <span style=color:#ae81ff>91</span>};
</span></span><span style=display:flex><span><span style=color:#75715e>// omitting the braces will lead `91` getting assigned to `marks[2]`
</span></span></span></code></pre></div><p>See how ambigious and error prone it becomes just by omitting the braces? When used correctly, it might save you a few keystrokes, but you would be shooting yourself in the foot in the long run!</p><p>Below is <a href=https://en.cppreference.com/w/cpp/language/aggregate_initialization#Explicitly_initialized_elements target=_blank>an example from cppreference</a> summarizing various scenarios,</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>base1</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> b1, b2 <span style=color:#f92672>=</span> <span style=color:#ae81ff>42</span>;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>base2</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> b3;
</span></span><span style=display:flex><span>    base2() { b3 <span style=color:#f92672>=</span> <span style=color:#ae81ff>42</span>; }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>derived</span> <span style=color:#f92672>:</span> base1, base2 {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> d;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>derived d1{{<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>}, {}, <span style=color:#ae81ff>4</span>}; <span style=color:#75715e>// initializes d1.b1 with 1, d1.b2 with 2,
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                           <span style=color:#75715e>//             d1.b3 with 42, d1.d with 4
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>derived d2{{}, {}, <span style=color:#ae81ff>4</span>};     <span style=color:#75715e>// initializes d2.b1 with 0, d2.b2 with 42,
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                           <span style=color:#75715e>//             d2.b3 with 42, d2.d with 4
</span></span></span></code></pre></div><p>Note that if there is a user declared default constructor (like in <code>base2</code>), then value-initialization will invoke it instead of value initializing the members.</p><h4 id=initializing-with-designated-initializers>initializing with designated initializers</h4><p>A designated initializer, or designator, points out a particular element to be initialized. A designator list is a comma-separated list of one or more designators. They must appear in the same order as the order of declaration. All the members without a designator having a default value are assigned that value. And the other members are initialized from an empty initializer list, similar to the above section.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Person</span> {
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>string name;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> age {<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>};
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>double</span> height;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Person person { .name <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Jane&#34;</span>, .height <span style=color:#f92672>=</span> <span style=color:#ae81ff>180.0</span> }; <span style=color:#75715e>// age = -1
</span></span></span></code></pre></div><p>Though this syntax (<em>3, 4</em>) has been around since <em>C99</em>, it made its debut (only for class types) in <em>C++20</em> with subtle differences.</p><p>Out-of-order designated initialization, nested designated initialization, mixing of designated initializers and regular initializers, and designated initialization of arrays are all supported in C, but are not allowed in C++.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>A</span> { <span style=color:#66d9ef>int</span> x, y; };
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>B</span> { <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>A</span> a; };
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>A</span> a <span style=color:#f92672>=</span> {.y <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>, .x <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>}; <span style=color:#75715e>// valid C, invalid C++ (out of order)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> arr[<span style=color:#ae81ff>3</span>] <span style=color:#f92672>=</span> {[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>5</span>};        <span style=color:#75715e>// valid C, invalid C++ (array)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>B</span> b <span style=color:#f92672>=</span> {.a.x <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>};       <span style=color:#75715e>// valid C, invalid C++ (nested)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>A</span> a <span style=color:#f92672>=</span> {.x <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>};      <span style=color:#75715e>// valid C, invalid C++ (mixed)
</span></span></span></code></pre></div><p>This form of initialization is sometimes helpful when new members are added to the definition.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>S</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> a;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> c;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>S s1 {.a <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>, .c <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>};
</span></span><span style=display:flex><span>S s2 {<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>}; <span style=color:#75715e>// a = 1, c = 2
</span></span></span></code></pre></div><p>In the example below, another member is added in between, the list initialization will need changes, but no changes are required for the designated initialization.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>S</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> a;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> b;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> c;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>S s1 {.a <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>, .c <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>}; <span style=color:#75715e>// no change here
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>S s2 {<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>}; <span style=color:#75715e>// b will get assigned 2 here
</span></span></span></code></pre></div><p>Note that the above scenario is only useful if and only if in all initialization/assignment occurances designated initializers are used, which is never really the case. That is why it is good practice to add any new members at the bottom so that the other members don&rsquo;t shift.</p><p>Last but not least, we can have a combination of both list and designated initialization when initializing a nested aggregate.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Student</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> id {<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>};
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> name[<span style=color:#ae81ff>20</span>];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> marks[<span style=color:#ae81ff>3</span>];
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Course</span> {
</span></span><span style=display:flex><span>    Student student;  <span style=color:#75715e>// Nested structure
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>double</span> grade;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Course c <span style=color:#f92672>=</span> {{.name <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Alice&#34;</span>, .marks <span style=color:#f92672>=</span> {<span style=color:#ae81ff>85</span>, <span style=color:#ae81ff>90</span>, <span style=color:#ae81ff>88</span>}}, <span style=color:#ae81ff>90.5</span>};
</span></span></code></pre></div><h3 id=initializing-from-a-struct>Initializing from a Struct</h3><p>Let&rsquo;s say we have a struct, and we want to initialize another struct with the same values. Lucky for us, C++ makes it pretty intuitive to do so without manually initializing each member. All it takes is <code>operator=</code>, also known as <em>copy initialization</em>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Node</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> val;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Node</span><span style=color:#f92672>*</span> next;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Node last <span style=color:#f92672>=</span> { <span style=color:#ae81ff>2</span> };
</span></span><span style=display:flex><span>Node first <span style=color:#f92672>=</span> { <span style=color:#ae81ff>1</span>, <span style=color:#f92672>&amp;</span>second };
</span></span><span style=display:flex><span>Node middle <span style=color:#f92672>=</span> first; <span style=color:#75715e>// copy initialization
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>first <span style=color:#f92672>=</span> { .val <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, .next <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>middle };
</span></span></code></pre></div><p>In addition to this type of initialization, there are two other syntax forms called <em>direct initialization</em> and <em>direct-list initialization</em>.</p><ol><li><code>T object2 = object1; // copy initialization</code></li><li><code>T object2(object1); // direct initialization</code></li><li><code>T object2 { object1 }; // direct-list initialization</code></li></ol><p>You might be thinking, &ldquo;But how does this work when we haven’t defined a constructor or overloaded <code>operator=</code>?&rdquo; Well, fret not. The compiler automatically generates a copy constructor when it’s missing, and all these syntax forms simply call it.</p><p>Let’s take a look at an example where we explicitly define two constructors: <em>default</em> and <em>copy</em>. This will help show how each syntax form calls the <em>copy constructor</em>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Node</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> val;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Node</span><span style=color:#f92672>*</span> next;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Node() { std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;default ctor invoked</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>; } 
</span></span><span style=display:flex><span>    Node(<span style=color:#66d9ef>const</span> Node<span style=color:#f92672>&amp;</span> other) { std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;copy ctor invoked</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>; }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Node d; <span style=color:#75715e>// default ctor invoked
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>Node a <span style=color:#f92672>=</span> d; <span style=color:#75715e>// copy ctor invoked
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>Node <span style=color:#a6e22e>b</span>(a); <span style=color:#75715e>// copy ctor invoked
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>Node c{b}; <span style=color:#75715e>// copy ctor invoked
</span></span></span></code></pre></div><h2 id=assigning-structs>Assigning Structs</h2><p>There will be times when not all the values of struct members are known at initialization. Later on, when the values become known, one option is to assign individually but there is always a chance of overlooking a few.</p><p>So, what are the best ways to assign values to structs correctly? Let’s explore a couple of approaches.</p><h3 id=assigning-with-initializer-lists>assigning with initializer lists</h3><p>Out of the four list-initialization forms discussed earlier, two of them <em>(1, 3)</em> can be used for assignments. To refresh your memory, these two forms of initialization are called <em>copy list initialization</em>.</p><ol><li><code>object = { arg1, arg2, ... };</code></li><li><code>object = { .des1 = arg1 , .des2 { arg2 } ... };</code> (since C++20)</li></ol><p>Let&rsquo;s revisit an earlier example,</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Person</span> {
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>string name;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> age {<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>};
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>double</span> height;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Person person { .name <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Jane&#34;</span>, .height <span style=color:#f92672>=</span> <span style=color:#ae81ff>180.0</span> };
</span></span><span style=display:flex><span>std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Enter date of birth: &#34;</span>;
</span></span><span style=display:flex><span>std<span style=color:#f92672>::</span>string dob;
</span></span><span style=display:flex><span>std<span style=color:#f92672>::</span>cin <span style=color:#f92672>&gt;&gt;</span> dob;
</span></span><span style=display:flex><span>person <span style=color:#f92672>=</span> { .name <span style=color:#f92672>=</span> person.name, .age <span style=color:#f92672>=</span> calc_age(dob) }; 
</span></span></code></pre></div><p>In this example, <code>age</code> was value-initialized to <code>-1</code> at first. Later, it gets recalculated and assigned. Since <code>name</code> didn&rsquo;t need to change, we just reused the previous value. However, here’s where things can trip you up: <code>height</code> was left out of the assignment and gets value-initialized to <code>0.0</code>, overwriting the original height value. Oops!</p><h3 id=assigning-another-struct-using-operator>assigning another struct using <code>operator=</code></h3><p>The syntax is similar to that of initializing from a struct using <code>operator=</code>.</p><ul><li><code>object2 = object1;</code></li></ul><p>But here&rsquo;s the difference: this time, it doesn&rsquo;t invoke the copy constructor. Instead, the compiler generates an overloaded assignment operator (if you don’t provide one), and this operator simply replaces the existing values in the left-hand struct with the ones from the right-hand struct.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>A</span> {
</span></span><span style=display:flex><span>    A() { std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;default ctor invoked</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>; }
</span></span><span style=display:flex><span>    A(<span style=color:#66d9ef>const</span> A<span style=color:#f92672>&amp;</span> other) { std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;copy ctor invoked</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>; }
</span></span><span style=display:flex><span>    A<span style=color:#f92672>&amp;</span> <span style=color:#66d9ef>operator</span><span style=color:#f92672>=</span>(<span style=color:#66d9ef>const</span> A<span style=color:#f92672>&amp;</span> other) { std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;operator= invoked</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>; }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>A a; <span style=color:#75715e>// default ctor invoked
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>A b <span style=color:#f92672>=</span> a; <span style=color:#75715e>// copy ctor invoked
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>a <span style=color:#f92672>=</span> b; <span style=color:#75715e>// operator= invoked
</span></span></span></code></pre></div><h2 id=to-be-continued>To Be Continued&mldr;</h2><p>At first, I had big dreams of covering everything there is to know about structs in a single article. But, let&rsquo;s be real—it was turning into a novel. So, I’ve decided to break it up into a trilogy (think <em>Lord of the Rings</em>, but with fewer swords and more code). Stay tuned for the next part, where I’ll dive deeper into how structs really shine in C++!</p></article><a href=# class=back-to-top aria-label="scroll back to top"><svg width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><polyline points="16 12 12 8 8 12"/><line x1="12" y1="16" x2="12" y2="8"/></svg></a><hr><script src=https://giscus.app/client.js data-repo=priyavrat-misra/personal-website data-repo-id=R_kgDOHXZkKg data-category=Announcements data-category-id=DIC_kwDOHXZkKs4Ccjrk data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=light data-lang=en data-loading=lazy crossorigin=anonymous async></script></main><footer><p><small class=text-muted>&copy; 2022-2025 Priyavrat Misra. All rights reserved.</small></p></footer></div></body></html>