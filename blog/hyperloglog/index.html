<!doctype html><html lang=en><head><title>Counting at Scale</title>
<meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=author content="Priyavrat Misra"><meta name=description content="A mathematical exploration of efficiently counting at scale, where traditional methods fall short."><link rel=canonical href=https://priyavr.at/blog/hyperloglog/><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link href=https://cdn.jsdelivr.net/npm/bootstrap@5.3.8/dist/css/bootstrap.min.css rel=stylesheet integrity=sha384-sRIl4kxILFvY47J16cr9ZwB07vP4J8+LH7qKQnuqkuIAvNWLzeN8tE5YBujZqJLB crossorigin=anonymous><link rel=stylesheet href=/css/theme.min.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.css integrity=sha384-zh0CIslj+VczCZtlzBcjt5ppRcsAmDnRem7ESsYwWwg3m/OaJ2l4x7YBZl9Kxxib crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.js integrity=sha384-Rma6DA2IPUwhNxmrB/7S3Tno0YY7sFu9WSYMCuulLhIqYSGZ2gKCJWIqhBWqMQfh crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/contrib/auto-render.min.js integrity=sha384-hCXGrW6PitJEwbkoStFjeJxv+fSOOQKOPbJxSfM6G5sWZjAyWhXiTIIAmQqnlLlh crossorigin=anonymous onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"\\[",right:"\\]",display:!0},{left:"$$",right:"$$",display:!0},{left:"\\(",right:"\\)",display:!1}],throwOnError:!1})})</script></head><body><div id=content class=mx-auto><header class="container mt-4"><div class=row><div class="col-sm-4 col-12 text-sm-end text-center pt-sm-4"><a href=/ class=text-decoration-none><img class=rounded-circle width=120 height=120 alt="Profile Picture" src=/images/avatar120w.webp srcset="/images/avatar180w.webp 180w, /images/avatar120w.webp 120w"></a></div><div class="col-sm-8 col-12 text-sm-start text-center"><h1 class="mb-2 mt-4"><a href=/ class=text-decoration-none>Priyavrat Misra</a></h1><p class="text-muted subtitle"></p><nav><ul class=list-inline><li class=list-inline-item><a href=https://www.linkedin.com/in/priyavrat-misra/ title=LinkedIn target=_blank class=text-muted><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M16 8a6 6 0 016 6v7h-4v-7a2 2 0 00-2-2 2 2 0 00-2 2v7h-4v-7a6 6 0 016-6z"/><rect x="2" y="9" width="4" height="12"/><circle cx="4" cy="4" r="2"/></svg></a></li><li class=list-inline-item><a href=https://github.com/priyavrat-misra title=GitHub target=_blank class=text-muted><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a></li><li class=list-inline-item><a href=https://www.strava.com/athletes/priyavrat title=Strava target=_blank class=text-muted><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><polyline points="22 12 18 12 15 21 9 3 6 12 2 12"/></svg></a></li><li class=list-inline-item><a href=mailto:priyavratmisra123@gmail.com title=Email target=_blank class=text-muted><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M4 4h16c1.1.0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1.0-2-.9-2-2V6c0-1.1.9-2 2-2z"/><polyline points="22,6 12,13 2,6"/></svg></a></li><li class=list-inline-item><a href=/blog/rss.xml title="RSS Feed" target=_blank class=text-muted><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></li></ul></nav><nav><ul class=list-inline><li class=list-inline-item><strong><a href=/blog/ title="Ramblings for the curious mind.">Blog</a></strong></li><li class=list-inline-item><strong><a href=/tags/ title=Tags>Tags</a></strong></li><li class=list-inline-item><strong><a href=https://nbviewer.org/github/priyavrat-misra/resume/blob/main/R%C3%A9sum%C3%A9.pdf title=Résumé>Résumé</a></strong></li></ul></nav></div></div><hr></header><main class=container><div class="ms-sm-4 me-sm-4"><header class=mb-3><h2 class=mb-0>Counting at Scale</h2><small class=text-muted>Published: 03 Jul 25 15:18 UTC</small>
<small class=text-muted>Last updated: 03 Jul 25 15:18 UTC</small><br><small><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z"/><line x1="7" y1="7" x2="7.01" y2="7"/></svg>
<a href=/tags/databases class="badge bg-secondary text-light text-decoration-none">databases</a>
<a href=/tags/system-design class="badge bg-secondary text-light text-decoration-none">system-design</a>
<a href=/tags/mathematics class="badge bg-secondary text-light text-decoration-none">mathematics</a></small><nav id=TableOfContents><ul><li><a href=#motivation>Motivation</a></li><li><a href=#the-problem>The Problem</a></li><li><a href=#data-streams-vs-accumulated-data>Data Streams vs. Accumulated Data</a></li><li><a href=#practical-approaches-and-their-pitfalls>Practical Approaches and their Pitfalls</a></li><li><a href=#enter-hyperloglog-a-probabilistic-solution>Enter HyperLogLog: A Probabilistic Solution</a><ul><li><a href=#how-hyperloglog-works>How HyperLogLog works?</a></li><li><a href=#bucketing-and-mergeability>Bucketing and Mergeability</a></li><li><a href=#why-not-just-use-the-mean>Why not just use the mean?</a></li></ul></li><li><a href=#real-world-impact>Real-World Impact</a></li><li><a href=#conclusion>Conclusion</a><ul><li><a href=#further-reading>Further Reading</a></li></ul></li></ul></nav></header><article><h3 id=motivation>Motivation</h3><p>Last weekend, I decided to delve deeper into the world of databases and stumbled upon the fantastic <a href=https://15445.courses.cs.cmu.edu/ target=_blank>CMU 15-445/645</a> course. After the introduction lecture, I jumped straight into the assignments. The first one, aptly named <a href=https://15445.courses.cs.cmu.edu/fall2024/project0/ target=_blank>C++ Primer</a>, is a straightforward programming task designed to assess your grasp of basic C++ features.</p><h3 id=the-problem>The Problem</h3><p>The problem? Track the number of <strong>unique</strong> users accessing a website in a single day. If this were a LeetCode problem, it would be a breeze—just toss all the users into an <code>unordered_set</code> and return its size. Easy, right? But, as with most things in life, real-world problems are rarely so simple—or so memory-friendly.</p><p>Let’s break down the “LeetCode way.” Imagine we’re working at Facebook, say about one billion unique users log in daily, and each user ID is around 8 bytes. Using an <code>unordered_set</code>, that’s 8 billion bytes of memory—about 7.7 GB—just to count users! All we really want is a single number. It’s like renting an entire stadium just to host a two-person meeting.</p><h3 id=data-streams-vs-accumulated-data>Data Streams vs. Accumulated Data</h3><p>But there’s another subtlety here: in real-world systems, we’re often dealing with a data stream, not a static, accumulated dataset. Users are constantly logging in, and we want to process each event as it happens—potentially across distributed servers—without storing the entire history of who has logged in so far.</p><p>The <code>unordered_set</code> solution works if we have all the data in memory and can afford to keep it there, but that’s rarely feasible at scale. In practice, we don’t want to keep every user ID we’ve ever seen—especially when the list can be massive and ever-growing. Instead, we need a way to estimate the number of unique users “on the fly,” using minimal memory, and without revisiting or accumulating all previous data.</p><h3 id=practical-approaches-and-their-pitfalls>Practical Approaches and their Pitfalls</h3><p>Let’s get practical. Suppose there’s a “last seen” metadata field associated with each user. We could increment a counter whenever “last seen” is updated from a timestamp that isn’t from the current day. Sounds simple, right? But in reality, every time a user opens the app, we’re hitting the database for a lookup—hardly efficient.</p><p>You might argue, “But we’re fetching user data anyway to show in the chat window, so why not cache and reuse it?” That’s true—<em>if</em> the user visits the chat window. If not, the lookup is only for the counter, which feels wasteful. Plus, we’re assuming the existence of a “last seen” field, which isn’t always available.</p><p>Now, consider a different question: “How many unique users have liked posts in the last month?” Here, we’re dealing with a different set of actions and data. Often, we have no choice but to perform full table scans, which can put serious strain on the database—much like asking your laptop to run Crysis on integrated graphics.</p><h3 id=enter-hyperloglog-a-probabilistic-solution>Enter HyperLogLog: A Probabilistic Solution</h3><p>The problem statement then brings us to HyperLogLog—a probabilistic algorithm designed to estimate the number of unique elements (the “cardinality”) in a data stream without explicitly storing every item. The key idea? The more unique elements we see, the more likely we are to encounter a hash with many contiguous zeroes.</p><blockquote><p>According to <a href=https://algo.inria.fr/flajolet/Publications/FlFuGaMe07.pdf target=_blank>HyperLogLog: The analysis of a near-optimal cardinality estimation algorithm</a>, the HyperLogLog algorithm is able to estimate cardinalities of \(>10^{9}\) with a typical accuracy (standard error) of \(2\%\), using \(1.5 kB\) of memory.</p></blockquote><h4 id=how-hyperloglog-works>How HyperLogLog works?</h4><p>HyperLogLog uses a hash function—ideally, one that produces uniformly distributed values. We take the user ID (or any suitable identifier), hash it to a numerical value, and use its binary representation. Some implementations consider the maximum number of trailing zeroes, others look at the maximum leftmost position of \(1\) (i.e., the maximum number of leading zeroes plus one). For our discussion, we’ll stick with the latter, as in the problem statement.</p><p>Assuming no hash collisions, our problem reduces to finding the number of unique binary strings. If you remember your high school math, for a random binary string, the probability of getting \(k\) leading zeroes followed by a one is \(1 / 2^{k+1}\).</p><p><img src=/images/leftmostOneProbability.svg alt="Probability of getting a leftmost one illustrated"></p><p>Alternatively, think of the string as a series of coin tosses: zero means heads, one means tails. If, across multiple individual runs, the longest run of heads we encountered is \(l\), then its probability is \(1 / 2^{l+1}\). In other words, we can estimate that, on average, we’ve tried at least \(2^{l+1}\) times.</p><p>To put it simply: if we see a maximum run of 2 heads, \(HHT\), we probably tossed the coin at least \(2^{2+1} = 8\) times, \(\{HHH, HHT, HTH, HTT, THH, THT, TTH, TTT\}\). The probability ends up being \(1 / 8\).</p><p>Note that, \(HHH\) isn&rsquo;t valid here because we considered the maximum leading heads to be 2, so technically it should be one less, but to keep things simple, we can round it off.</p><p>Try to solve for a maximum run of 10 heads—notice how quickly the probability drops!</p><p>The chance of seeing a hash with many leading zeroes is very low, and the more unique elements we see, the higher the chance we’ll encounter such a hash. However, it’s still possible—thanks to uniform hashing—to get unlucky and see a binary string with many leading zeroes after just a few tries. These are outliers, and HyperLogLog has a clever way of handling them.</p><h4 id=bucketing-and-mergeability>Bucketing and Mergeability</h4><p>To manage outliers, HyperLogLog distributes the hash values into different buckets based on the initial \(b\) bits of the hash. This gives us a total of \(2^b\) buckets, each tracking its own maximum. Even though we’re distributing values, the maximum among them remains the same, so our problem is <em>mergeable</em>—we don’t have to worry about double-counting.</p><p><img src=/images/hllBuckets.svg alt="Bucketing in HyperLogLog illustrated"></p><p>This property is incredibly useful for questions like, “How many unique users have liked posts in the last month?” We can easily combine the buckets for each day and calculate the result. To do this, we persist each day’s serialized HyperLogLog structure (typically just a few kilobytes—no big deal). The mergeability of HyperLogLog is also a boon in distributed systems: each server can maintain its own buckets, which can later be aggregated.</p><h4 id=why-not-just-use-the-mean>Why not just use the mean?</h4><p>So, what if we take the average of all the maximums across the buckets? Does it solve the outlier problem? Unfortunately, no. The average is still affected by outliers. Instead, HyperLogLog uses the <em>harmonic mean</em>, which is less sensitive to large outliers.</p><p>Let \(b\) be the number of bits chosen to identify a bucket, giving us \(m = 2^b\) buckets. Let \(p_i\) be the maximum leftmost position of \(1\) seen so far for bucket \(i\). The cardinality estimate is calculated as:</p>\[CARDINALITY_{HLL} = 0.79402 * m * \frac{m}{\sum_{i=0}^{m-1} 2^{-p_i}}\]<p>Notice that outliers appear in the denominator as \(p_i\), contributing only slightly to the cardinality. Also, the more buckets we have, the more outliers we can handle, and the more accurate the cardinality estimate becomes (although this does require more memory).</p><h3 id=real-world-impact>Real-World Impact</h3><p>The efficiency and scalability of HyperLogLog have cemented its place as an industry standard for large-scale unique counting. For instance, Redis offers built-in HyperLogLog support, enabling developers to track unique website visitors or event occurrences with just a few kilobytes of memory. Likewise, Google Analytics relies on similar probabilistic algorithms to deliver fast, accurate unique user counts across billions of events, powering real-time analytics on a global scale. Beyond these high-profile examples, HyperLogLog is widely used in streaming analytics dashboards, traffic heatmaps, and any scenario where massive data volumes demand both accuracy and minimal memory usage.</p><h3 id=conclusion>Conclusion</h3><p>I hope you found this exploration as engaging to read as I did to put together! Thanks for joining me on this deep dive.</p><h4 id=further-reading>Further Reading</h4><ul><li><a href=https://algo.inria.fr/flajolet/Publications/FlFuGaMe07.pdf target=_blank>Original HyperLogLog Paper (PDF)</a></li><li><a href=https://engineering.fb.com/2018/12/13/data-infrastructure/hyperloglog/ target=_blank>A blog on Meta's implementation of HLL</a></li><li><a href=https://redis.io/docs/latest/develop/data-types/probabilistic/hyperloglogs/ target=_blank>HyperLogLog in Redis</a></li><li><a href=https://cloud.google.com/bigquery/docs/reference/standard-sql/approximate_aggregate_functions#approx_count_distinct target=_blank>BigQuery’s Approximate Count Distinct</a></li></ul></article></div><a href=# class=back-to-top aria-label="scroll back to top"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><polyline points="16 12 12 8 8 12"/><line x1="12" y1="16" x2="12" y2="8"/></svg></a><hr><script src=https://giscus.app/client.js data-repo=priyavrat-misra/personal-website data-repo-id=R_kgDOHXZkKg data-category=Announcements data-category-id=DIC_kwDOHXZkKs4Ccjrk data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=light data-lang=en data-loading=lazy crossorigin=anonymous async></script></main></div><footer><p><small class=text-muted>&copy; 2022-2025 Priyavrat Misra. All rights reserved.</small></p></footer></body></html>